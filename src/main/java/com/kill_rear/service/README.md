服务类
ajax是基于url形式的服务类
twoplayers是双人模式下的服务类，包括请求匹配、处理回应、游戏初始化、游戏进行时
common保存了和游戏有关的房间数据结构类、以及WebSession。前者的数据是全部给到前端，后者主要提供向指定客户端发送消息的接口


三国杀本质是技能驱动型游戏，具有如下的特点：
1、如果有技能执行效果，一次只能执行一个
2、正在执行处理的技能A可以被另一技能B中断，条件是B可以响应A。
这是一个栈模型。
我们使用一个技能运行时类来描述这个过程。

我们的运行模型是询问外部输入的计算机，它允许多级中断的产生（中断就是技能），暂且称这个为模型M。

模型M中的特点是：
    1、执行过程中，只有当M允许用户输入的时候，用户才能输入，开不开其由M说了算。
    2、当M开启询问之后，用户通过点击操作产生一次又一次的输入。

    3、对于三国杀游戏而言，当游戏初始化完毕之后，玩家轮流执行一个回合，M会模拟这一过程。

    4、回合分成各个阶段，最重要也是最复杂是出牌阶段，M会开启询问，这个时候当前轮次的玩家可以输入。

    5、出牌阶段的逻辑如下：
        1、M会在“出牌阶段”特殊技能，计算可以中断它的所有技能，然后通知玩家这些可以触发。

        2、每当M被调用与解释技能有关的api时，它就会分析栈顶的技能，并会调用当前栈顶技能
            与用户下一步可以再次点击的游戏对象有关。

        栈就是保存技能运行时。

        3、当玩家产生一个输入之后，M会根据这个输入类型，转入不同的处理函数。
            如果是玩家，那么M会记录本次对象到栈顶技能运行时类。
            如果是武将技能，那么M检查该技能效果是否可以影响到当前栈顶的技能。
                如果可以，那么产生一个新的技能运行时类并压入栈，转而处理这个类。
                如果不可以，那么本次的点击是无效，事实上，这种情况也是不存在的，参见见上面，我们已计算出了所有可能被点击的对象。

            如果是手牌，那么依然检查该技能效果，但是和前面有点不一样的是，武将技能点击是独立的，而手牌的点击却不一定.
                需要栈顶技能去检查本次的目标到达是发动该技能需要的条件, 还是响应.
                (如果是前者, 那么技能运行时类的状态不是Running, 而后者则是Running, 所以依然可以通过M去检查)
            
            如果是装备区, 那么和武将的一样.
            如果是其他CARD, 例如五谷丰登 过河拆桥这些, 那么我们依然像手牌一样处理.

            如果是按钮, 那么需要分情况, 以后再补

            如果是空
                如果是当前栈顶技能不是Running, 那么取消当前技能的触发.
                如果是Running, 那么直接调用当前栈顶技能的与响应结果处理有关的函数.

            到此, 所有类型基本上都被覆盖到了.
    
    6、游戏数据格式的定义(未完成):
        {
            api: 'play'
            stage: 'start' | 'update' | 'end'
            data:
                不同阶段, 数据不同.
        }

    7 技能如何处理响应技能: 按照刚才的栈模型,B响应了A, 那么B的结果需要在B生效后, 
        提交到栈顶之后的A.

                         A->B              M
    出     ->     杀     ->     B点击八卦阵 -> 
    running   beforeRunning  



栈情况:
    出->杀->八卦阵

M询问司马懿, 是否发动改命, 司马确定, 那么
    出->杀(running)
司马点击红心牌, 改判分析出合理, 提示confrim按钮显示.
然后司马, 点击confrim, 那么启动改判.
发动丢牌技能, 技能处理生效后.
丢牌技能将红心给到改判.
改判生效后, 将判定技能换成红心.
判定有效, 将技能给到八卦阵.
八卦阵效果产生一个闪.
M检查是闪进入到生效阶段否有依赖技会发动,如果没有,那么把出了一个闪结果给到杀.
杀处理结果, 杀生效, 技能给到出牌技能.
调用出牌阶段响应功能, 继续等待出牌.



双人模式下：
选取武将：后 -> 前
{
    roomId：int-roomId
    api：select
    generals: []  可选武将列表
}

message的data字段
前->后
{
    roomId,
    pattern:
    chooseId;
}

